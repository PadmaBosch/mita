@GenModel(copyrightText="generated by Xtext 2.13.0", operationReflection="false", modelDirectory="/org.eclipse.mita.types/emf-gen")
package org.eclipse.mita.types

/********************************************************************************
 * Copyright (c) 2017, 2018 Bosch Connected Devices and Solutions GmbH.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * Contributors:
 *    Bosch Connected Devices and Solutions GmbH - initial contribution
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/


import org.yakindu.base.expressions.expressions.Expression
import org.yakindu.base.types.ComplexType
import org.yakindu.base.types.Operation
import org.yakindu.base.types.Parameter
import org.yakindu.base.types.PrimitiveType
import org.yakindu.base.types.Type


abstract class GeneratedElement {
	/**
	 * The fully-qualified class name of the generator class. 
	 */
	String generator
	
	/**
	 * The optional fully-qualified name of the validator class.
	 */
	String validator
	
	/**
	 * The optional fully-qualified name of the element size inferrer class.
	 */
	String sizeInferrer
}


interface HasAccessors {
	/**
	 * caution: this is only the type from the parsed model, not neccessarily the inferred type. Use with caution for type inferrence.
	 */
	op Type[] accessorsTypes()
}

class Exportable {
	boolean exported
}

class ExceptionTypeDeclaration extends Type, Exportable {
}

class NativeType extends PrimitiveType, Exportable {
	String aliasOf
	String header
	
	op String getCName() {
		if(aliasOf === null) {
			return name
		} else {
			return aliasOf
		}
	}
	
	op String toString() {
		return name
	}
}

class EnumerationType extends org.yakindu.base.types.EnumerationType, Exportable {
	op String toString() {
		return super.toString()
	}
}

class TypeSpecifier extends org.yakindu.base.types.TypeSpecifier {
	transient boolean optional
	transient String[] referenceModifiers
	
	op String toString() {
		val args = if(typeArguments.empty) {
			""
		} else {
			"<" + typeArguments.map[if(it === null) {"null"} else {it.toString}].reduce[p1, p2| p1 + ", " + p2] + ">"
		}
		val typeName = if(^type === null) {
			"null"
		} else {
			^type.toString
		}
		return typeName + args;
	}
}

class StructureType extends org.yakindu.base.types.ComplexType, HasAccessors, Exportable {
	contains Parameter[] parameters
	op Type[] accessorsTypes() {
		return parameters.map[it.typeSpecifier.^type];
	}
	
	op String toString() {
		super.toString
	}
}

class GeneratedType extends org.yakindu.base.types.ComplexType, GeneratedElement, Exportable {
	contains Operation constructor
	
	op String toString() {
		super.toString
	}
}

class GeneratedTypeParameter extends Parameter {
	boolean ^static
	contains Expression value
} 

class PackageAssociation {
	String name
}

class ImportStatement {
	String importedNamespace
}
 

class SumType extends ComplexType, Exportable {
	// I would use features, but if I want to have SumAlternative as a ComplexType (which it is), then I can't make it a Declaration as well
	contains SumAlternative[] alternatives
	
	op String toString() {
		return super.toString();
	}
}
interface SumAlternative extends ComplexType, HasAccessors {
	op Type realType() {
		return this;
	}
}
class Singleton extends SumAlternative {
	op Type[] accessorsTypes() {
		return #[].asEList;
	}
}
class AnonymousProductType extends SumAlternative {
	contains org.yakindu.base.types.TypeSpecifier[] typeSpecifiers 
	op Type realType() {
		if(typeSpecifiers.length == 1) {
			return typeSpecifiers.get(0).^type;
		}
		else {
			return this;
		}
	}
	op Type[] accessorsTypes() {
		// need to duplicate functionality, since calling realType and deferring to that ones accessor types would create infinite recursion if it returns this
		// could check with == this, but that would be more confusing I think
		if(typeSpecifiers.length == 1) {
			val realType = typeSpecifiers.get(0).^type;
			if(realType instanceof HasAccessors) {
				return realType.accessorsTypes;
			}
		}
		else {
			return typeSpecifiers.map[it.^type];
		}
	}
}
class NamedProductType extends SumAlternative, HasAccessors {
	contains Parameter[] parameters
	// always return parameter types, since we never embed
	op Type[] accessorsTypes() {
		return parameters.map[it.typeSpecifier.^type];
	}
}
class ProductMember extends Parameter { }

